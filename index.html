<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Tic-Tac-Toe AI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom Animations */
        .path-draw {
            stroke-dasharray: 100;
            stroke-dashoffset: 100;
            animation: drawLine 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        .circle-draw {
            stroke-dasharray: 283; /* 2 * pi * 45 (approx radius) */
            stroke-dashoffset: 283;
            animation: drawCircle 0.6s cubic-bezier(0.4, 0, 0.2, 1) forwards;
        }

        @keyframes drawLine {
            to { stroke-dashoffset: 0; }
        }

        @keyframes drawCircle {
            to { stroke-dashoffset: 0; }
        }

        .fade-in {
            animation: fadeIn 0.3s ease-out forwards;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        /* Neon Glow Effects */
        .cell {
            transition: background-color 0.3s, box-shadow 0.3s;
        }
        .cell:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .x-glow {
            filter: drop-shadow(0 0 4px #22d3ee) drop-shadow(0 0 8px #0891b2);
        }
        
        .o-glow {
            filter: drop-shadow(0 0 4px #f472b6) drop-shadow(0 0 8px #be185d);
        }

        .win-line-glow {
            filter: drop-shadow(0 0 5px #facc15) drop-shadow(0 0 10px #eab308);
        }

        /* Modal Backdrop */
        .modal-backdrop {
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(4px);
        }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 min-h-screen flex flex-col items-center justify-center font-sans selection:bg-cyan-500 selection:text-white overflow-hidden">

    <!-- Game Container -->
    <div class="relative w-full max-w-md px-4 flex flex-col items-center">
        
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold bg-gradient-to-r from-cyan-400 to-pink-500 bg-clip-text text-transparent mb-2 tracking-wider">TIC TAC TOE</h1>
            <p class="text-slate-400 text-sm font-medium tracking-wide">UNBEATABLE AI</p>
        </div>

        <!-- Score / Status -->
        <div class="flex justify-between w-full px-4 mb-6 text-sm font-semibold tracking-widest text-slate-400">
            <div id="player-status" class="flex items-center gap-2 text-cyan-400 transition-opacity duration-300">
                <span>YOU (X)</span>
            </div>
            <div id="ai-status" class="flex items-center gap-2 opacity-50 transition-opacity duration-300">
                <span>AI (O)</span>
            </div>
        </div>

        <!-- Board Wrapper -->
        <div class="relative">
            <!-- The Grid -->
            <div class="grid grid-cols-3 gap-3 p-3 bg-slate-800/50 rounded-2xl shadow-2xl border border-slate-700 backdrop-blur-sm" id="board">
                <!-- Cells generated by JS -->
            </div>

            <!-- SVG Overlay for Winning Line -->
            <svg id="win-overlay" class="absolute top-0 left-0 w-full h-full pointer-events-none z-10 hidden" viewBox="0 0 300 300">
                <line id="win-line" x1="0" y1="0" x2="0" y2="0" stroke="#facc15" stroke-width="6" stroke-linecap="round" class="win-line-glow" />
            </svg>
        </div>

        <!-- Difficulty / Reset -->
        <div class="mt-10 flex gap-4">
            <button onclick="resetGame()" class="px-6 py-2 bg-slate-800 hover:bg-slate-700 border border-slate-600 rounded-full text-slate-300 font-semibold transition-all hover:shadow-lg active:scale-95 text-sm uppercase tracking-wider">
                Reset Board
            </button>
        </div>

    </div>

    <!-- Game Over Modal -->
    <div id="game-over-modal" class="fixed inset-0 modal-backdrop flex items-center justify-center z-50 hidden opacity-0 transition-opacity duration-300">
        <div class="bg-slate-800 border border-slate-600 p-8 rounded-2xl shadow-2xl text-center transform scale-90 transition-transform duration-300 max-w-xs w-full mx-4">
            <h2 id="modal-title" class="text-3xl font-bold mb-2 text-white">Game Over</h2>
            <p id="modal-message" class="text-slate-400 mb-6">Result message here</p>
            <button onclick="closeModalAndReset()" class="w-full py-3 bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-400 hover:to-blue-500 text-white font-bold rounded-xl shadow-lg transition-all active:scale-95">
                Play Again
            </button>
        </div>
    </div>

    <script>
        /**
         * Game Configuration & State
         */
        const boardElement = document.getElementById('board');
        const modal = document.getElementById('game-over-modal');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const winOverlay = document.getElementById('win-overlay');
        const winLine = document.getElementById('win-line');
        const playerStatus = document.getElementById('player-status');
        const aiStatus = document.getElementById('ai-status');

        const HUMAN = 'X';
        const AI = 'O';
        let board = Array(9).fill(null);
        let gameActive = true;
        let currentPlayer = HUMAN; // Human goes first
        
        // Initialize Board UI
        function initBoard() {
            boardElement.innerHTML = '';
            for (let i = 0; i < 9; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell', 'w-20', 'h-20', 'bg-slate-700/50', 'rounded-xl', 'cursor-pointer', 'flex', 'items-center', 'justify-center', 'relative');
                // Mobile responsive adjustment
                if (window.innerWidth < 400) {
                    cell.classList.remove('w-20', 'h-20');
                    cell.classList.add('w-16', 'h-16');
                }
                cell.dataset.index = i;
                cell.addEventListener('click', handleCellClick);
                boardElement.appendChild(cell);
            }
            updateStatusUI();
        }

        /**
         * Game Logic
         */
        function handleCellClick(e) {
            const index = e.target.closest('.cell').dataset.index;

            if (board[index] || !gameActive || currentPlayer !== HUMAN) return;

            makeMove(index, HUMAN);

            if (gameActive) {
                // Small delay for AI "thinking" effect
                currentPlayer = AI;
                updateStatusUI();
                setTimeout(() => {
                    const aiMove = getBestMove();
                    makeMove(aiMove, AI);
                }, 600);
            }
        }

        function makeMove(index, player) {
            board[index] = player;
            const cell = boardElement.children[index];
            
            // Draw Symbol
            if (player === HUMAN) {
                cell.innerHTML = getXSVG();
                cell.classList.add('text-cyan-400');
            } else {
                cell.innerHTML = getOSVG();
                cell.classList.add('text-pink-400');
            }

            // Check Win/Draw
            const winData = checkWin(board, player);
            if (winData) {
                gameActive = false;
                drawWinningLine(winData);
                setTimeout(() => showGameOver(player === HUMAN ? "You Won!" : "AI Won!"), 1500);
            } else if (checkDraw(board)) {
                gameActive = false;
                setTimeout(() => showGameOver("It's a Draw"), 500);
            } else {
                currentPlayer = player === HUMAN ? AI : HUMAN;
                updateStatusUI();
            }
        }

        function updateStatusUI() {
            if (currentPlayer === HUMAN) {
                playerStatus.classList.remove('opacity-50', 'text-slate-500');
                playerStatus.classList.add('text-cyan-400');
                aiStatus.classList.add('opacity-50');
                aiStatus.classList.remove('text-pink-400');
            } else {
                aiStatus.classList.remove('opacity-50');
                aiStatus.classList.add('text-pink-400');
                playerStatus.classList.add('opacity-50');
                playerStatus.classList.remove('text-cyan-400');
            }
        }

        /**
         * SVG Assets
         */
        function getXSVG() {
            return `
                <svg viewBox="0 0 100 100" class="w-2/3 h-2/3 x-glow block">
                    <line x1="20" y1="20" x2="80" y2="80" stroke="currentColor" stroke-width="10" stroke-linecap="round" class="path-draw" />
                    <line x1="80" y1="20" x2="20" y2="80" stroke="currentColor" stroke-width="10" stroke-linecap="round" class="path-draw" style="animation-delay: 0.2s;" />
                </svg>
            `;
        }

        function getOSVG() {
            return `
                <svg viewBox="0 0 100 100" class="w-2/3 h-2/3 o-glow block">
                    <circle cx="50" cy="50" r="35" stroke="currentColor" stroke-width="10" fill="transparent" stroke-linecap="round" class="circle-draw" />
                </svg>
            `;
        }

        /**
         * Visuals: Winning Line
         */
        function drawWinningLine(winData) {
            const [a, b, c] = winData.indices;
            const cells = boardElement.children;
            
            // Get center coordinates relative to the board
            const getCenter = (index) => {
                const cell = cells[index];
                const rect = cell.getBoundingClientRect();
                const boardRect = boardElement.getBoundingClientRect();
                return {
                    x: rect.left - boardRect.left + rect.width / 2,
                    y: rect.top - boardRect.top + rect.height / 2
                };
            };

            const start = getCenter(a);
            const end = getCenter(c);

            // Update SVG line
            winLine.setAttribute('x1', start.x);
            winLine.setAttribute('y1', start.y);
            winLine.setAttribute('x2', end.x);
            winLine.setAttribute('y2', end.y);
            
            // Animate line
            winLine.style.strokeDasharray = "500";
            winLine.style.strokeDashoffset = "500";
            winLine.style.animation = "drawLine 0.5s ease-out forwards";

            winOverlay.setAttribute('viewBox', `0 0 ${boardElement.offsetWidth} ${boardElement.offsetHeight}`);
            winOverlay.classList.remove('hidden');
        }

        /**
         * AI Engine: Minimax
         */
        function getBestMove() {
            let bestScore = -Infinity;
            let move;
            
            // Optimization: If center is open, take it (saves recursion)
            if(board[4] === null) return 4;

            for (let i = 0; i < 9; i++) {
                if (board[i] === null) {
                    board[i] = AI;
                    let score = minimax(board, 0, false);
                    board[i] = null;
                    if (score > bestScore) {
                        bestScore = score;
                        move = i;
                    }
                }
            }
            return move;
        }

        const scores = {
            X: -10,
            O: 10,
            tie: 0
        };

        function minimax(board, depth, isMaximizing) {
            // Check terminal states
            let result = checkWinnerForMinimax(board);
            if (result !== null) {
                return scores[result];
            }

            if (isMaximizing) {
                let bestScore = -Infinity;
                for (let i = 0; i < 9; i++) {
                    if (board[i] === null) {
                        board[i] = AI;
                        let score = minimax(board, depth + 1, false);
                        board[i] = null;
                        bestScore = Math.max(score, bestScore);
                    }
                }
                return bestScore;
            } else {
                let bestScore = Infinity;
                for (let i = 0; i < 9; i++) {
                    if (board[i] === null) {
                        board[i] = HUMAN;
                        let score = minimax(board, depth + 1, true);
                        board[i] = null;
                        bestScore = Math.min(score, bestScore);
                    }
                }
                return bestScore;
            }
        }

        function checkWinnerForMinimax(board) {
            const win = checkWin(board, HUMAN) ? HUMAN : checkWin(board, AI) ? AI : null;
            if (win) return win;
            if (checkDraw(board)) return 'tie';
            return null;
        }

        /**
         * Win/Draw Logic
         */
        function checkWin(currentBoard, player) {
            const wins = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // Rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // Cols
                [0, 4, 8], [2, 4, 6]             // Diagonals
            ];

            for (let combination of wins) {
                if (currentBoard[combination[0]] === player && 
                    currentBoard[combination[1]] === player && 
                    currentBoard[combination[2]] === player) {
                    return { indices: combination };
                }
            }
            return null;
        }

        function checkDraw(currentBoard) {
            return currentBoard.every(cell => cell !== null);
        }

        /**
         * Modal & Reset Handling
         */
        function showGameOver(message) {
            modalTitle.innerText = message === "It's a Draw" ? "Draw!" : message;
            modalMessage.innerText = message === "AI Won!" ? "Better luck next time." : 
                                     message === "You Won!" ? "Impossible! How?" : "Good game.";
            
            modal.classList.remove('hidden');
            // Trigger animation
            requestAnimationFrame(() => {
                modal.classList.remove('opacity-0');
                modal.querySelector('div').classList.remove('scale-90');
                modal.querySelector('div').classList.add('scale-100');
            });
        }

        function closeModalAndReset() {
            modal.classList.add('opacity-0');
            modal.querySelector('div').classList.remove('scale-100');
            modal.querySelector('div').classList.add('scale-90');
            setTimeout(() => {
                modal.classList.add('hidden');
                resetGame();
            }, 300);
        }

        function resetGame() {
            board = Array(9).fill(null);
            gameActive = true;
            currentPlayer = HUMAN;
            winOverlay.classList.add('hidden');
            initBoard();
        }

        // Handle resize for line drawing accuracy
        window.addEventListener('resize', () => {
             // Re-drawing line logic if game is won would go here, 
             // but strictly resetting is cleaner for this demo to avoid complex state management on resize.
             if(!gameActive && !checkDraw(board)) {
                 winOverlay.classList.add('hidden'); 
             }
        });

        // Initialize
        initBoard();

    </script>
</body>
</html>
